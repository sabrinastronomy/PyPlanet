"""
This file contains code to extract data for more complete planetary phases within the mantle, including combinations of
enstatite, perovskite, and molten silicates. EoSes all generated by Jisheng Zhang
Written by Jisheng Zhang and Sabrina Berger
"""

eos_loc = "/Users/sabrinaberger/Desktop/EoS"

import numpy as np
from scipy import interpolate
from pynbody.analysis.interpolate import interpolate2d
import matplotlib.pyplot as plt
import os
plt.rc('font', family='serif')

class AdiabaticMantleEOS:
    def __init__(self, S_setting = 3100, P_mantle_planet = np.logspace(1, 11, 100), need_plot=False):
        self.n = len(P_mantle_planet)# length of array to interpolate over
        self.S_setting = S_setting
        self.S_mantle_planet = np.ones(self.n) * self.S_setting  # varying temperature
        self.P_mantle_planet = P_mantle_planet  # varying pressure
        self.y = np.zeros(self.n)
        self.mantle_global_P = np.empty(len(P_mantle_planet))
        self.mantle_global_T = np.empty(len(P_mantle_planet))
        self.mantle_global_rho = np.empty(len(P_mantle_planet))
        self.mantle_global_Cp = np.empty(len(P_mantle_planet))
        self.mantle_global_mat = np.empty(len(P_mantle_planet))

        self.interpolate_everything()
        if need_plot:
            self.test_plot()


    def interpolate_everything(self):
        P = self.P_mantle_planet
        y = self.y
        S = self.S_mantle_planet
        # independent variables are pressure and entropy
        original_direc = os.getcwd()
        os.chdir(eos_loc) #loading in files from EoS directory

        ### relevant constants
        G = 6.674 * 10 ** (-11)  # SI
        k_b = 1.38 * 10 ** (-23)  # J/K
        N_A = 6.022 * 10 ** 23  # mol^-1
        L_pv = 7.322 * 10.0 ** 5.0

        ### min and max entropy
        S_max = 4410.0  # 4210.0
        S_min = 100.0

        ### load in all of Jisheng's file

        # post perovskite
        T_ppv = np.loadtxt("T_mix_ppv_Py.txt")
        rho_ppv = np.loadtxt("rho_mix_ppv_Py.txt")
        CP_ppv = np.loadtxt("CP_mix_ppv_Py.txt")
        alpha_ppv = np.loadtxt("alpha_mix_ppv_Py.txt")

        # molten silicates
        T_liq = np.loadtxt('T_liq_Py_500GPa.txt')
        rho_liq = np.loadtxt('rho_liq_Py_500GPa.txt')
        CP_liq = np.loadtxt('CP_liq_Py_500GPa.txt')

        alpha_liq = np.loadtxt('alpha_liq_Py_500GPa.txt')
        dTdP_liq = np.loadtxt('dTdP_liq_Py_500GPa.txt')
        dqdy_liq = np.loadtxt('dqdy_liq_Py_500GPa.txt')

        # solid perovskite
        T_sol_pv = np.loadtxt('T_sol_pv_Py_500GPa.txt')
        rho_sol_pv = np.loadtxt('rho_sol_pv_Py_500GPa.txt')
        CP_sol_pv = np.full(np.shape(rho_sol_pv), 1260)
        alpha_sol_pv = np.loadtxt('alpha_sol_pv_Py_500GPa.txt')  # thermal expansion coefficient
        dTdP_sol_pv = np.loadtxt('dTdP_sol_pv_Py_500GPa.txt')  # adiabatic temeprature gradient
        dqdy_sol_pv = np.loadtxt('dqdy_sol_pv_Py_500GPa.txt')  # Same as dqdy for iron.
        S_sol_pv = np.loadtxt('S_sol_pv_Py_500GPa.txt')

        # solid enstatite
        T_sol_ol = np.loadtxt('T_sol_ol_Py_500GPa.txt')
        rho_sol_ol = np.loadtxt('rho_sol_ol_Py_500GPa.txt')
        CP_sol_ol = np.full(np.shape(rho_sol_ol), 1250)
        alpha_sol_ol = np.loadtxt('alpha_sol_ol_Py_500GPa.txt')
        dTdP_sol_ol = np.loadtxt('dTdP_sol_ol_Py_500GPa.txt')
        dqdy_sol_ol = np.loadtxt('dqdy_sol_ol_Py_500GPa.txt')
        S_sol_ol = np.loadtxt('S_sol_ol_Py_500GPa.txt')

        # mix solid / liquid silicates
        T_mix_pv = np.loadtxt('T_mix_pv_Py_500GPa.txt')
        rho_mix_pv = np.loadtxt('rho_mix_pv_Py_500GPa.txt')
        CP_mix_pv = np.loadtxt('CP_mix_pv_Py_500GPa.txt')
        alpha_mix_pv = np.loadtxt('alpha_mix_pv_Py_500GPa.txt')
        dTdP_mix_pv = np.loadtxt('dTdP_mix_pv_Py_500GPa.txt')
        dqdy_mix_pv = np.loadtxt('dqdy_mix_pv_Py_500GPa.txt')
        S_mix_pv = np.loadtxt('S_mix_pv_Py_500GPa.txt')

        # mixture of enstatite and liquid silicates
        T_mix_ol = np.loadtxt('T_mix_ol_Py_500GPa.txt')
        rho_mix_ol = np.loadtxt('rho_mix_ol_Py_500GPa.txt')
        CP_mix_ol = np.loadtxt('CP_mix_ol_Py_500GPa.txt')
        alpha_mix_ol = np.loadtxt('alpha_mix_ol_Py_500GPa.txt')
        dTdP_mix_ol = np.loadtxt('dTdP_mix_ol_Py_500GPa.txt')
        dqdy_mix_ol = np.loadtxt('dqdy_mix_ol_Py_500GPa.txt')
        S_mix_ol = np.loadtxt('S_mix_ol_Py_500GPa.txt')

        # interpolation done on these grids below:
        y_grid = np.loadtxt('y_500GPa.txt') # note that this y file is the same as y.txt
        P_grid_ol = np.loadtxt('P_ol_500GPa.txt')
        P_grid_pv = np.loadtxt('P_pv_500GPa.txt')
        P_grid_ppv = np.loadtxt('P_ppv.txt')

        # This file gives you entropy on the liquidus and solidus, which you'll need to get y.
        P_solidus_liquidus = np.loadtxt('solid_P_500GPa.txt')

        # going back to original directory
        os.chdir(original_direc)

        ### Setting S, P, and y arrays
        # interpolate to an entropy from given pressure and temperature

        ### Getting pressure and associated entropy
        P_grid = P_solidus_liquidus[:, 0].copy()
        S_sol_array = P_solidus_liquidus[:, 1].copy()
        S_liq_array = P_solidus_liquidus[:, 2].copy()

        ### Calculating temperature of liquidus and solidus
        # setting up empty arrays
        T_sol_array = np.zeros(len(P_grid))
        T_liq_array = np.zeros(len(P_grid))

        for i in range(len(P_grid)):
            T_sol_array[i] = self.T_sol_fiq(P_grid[i] / 1e9)
            T_liq_array[i] = self.T_liq_fiq(P_grid[i] / 1e9)

        # interpolating to liqiudus and solidus respective entropy and temperature
        S_liq_P = interpolate.interp1d(P_grid, S_liq_array, fill_value="extrapolate")
        S_sol_P = interpolate.interp1d(P_grid, S_sol_array, fill_value="extrapolate")
        T_liq_P = interpolate.interp1d(P_grid, T_liq_array, fill_value="extrapolate")
        T_sol_P = interpolate.interp1d(P_grid, T_sol_array, fill_value="extrapolate")

        # Get liquidus and solidus temperature and entropy on your pressure grid.
        S_liquidus = np.zeros(self.n)
        S_solidus = np.zeros(self.n)
        T_solidus = np.zeros(self.n)
        T_liquidus = np.zeros(self.n)

        for i in range(self.n):  # getting values of S & T, liquidus and solidus for P values of planet!
            S_liquidus[i] = S_liq_P(P[i])
            S_solidus[i] = S_sol_P(P[i])
            T_solidus[i] = T_sol_P(P[i])
            T_liquidus[i] = T_liq_P(P[i])

        # i values corresponding to liquid, solid, and mixture
        i_liquid = []
        i_solid_enstatite = []
        i_solid_perovskite = []
        i_solid_ppv = []
        i_mixture_enstatite = []
        i_mixture_perovskite = []

        for i in range(self.n):
            if S[i] >= S_liquidus[i]:  # liquid phase
                y[i] = (S[i] - S_liquidus[i]) / (S_max - S_liquidus[i])
                i_liquid.append(i)
                # print("liquid")
            elif S[i] <= S_solidus[i]:  # solid phase
                y[i] = (S[i] - S_min) / (S_solidus[i] - S_min)
                if P[i] > 125e9: # post perovskite
                    # print("post perovskite")
                    i_solid_ppv.append(i)
                if P[i] > 23e9:  # perovskite
                    # print("solid perovskite")
                    i_solid_perovskite.append(i)
                else:
                    # print("solid enstatite")
                    i_solid_enstatite.append(i)
            else:  # mixture
                y[i] = (S[i] - S_solidus[i]) / (S_liquidus[i] - S_solidus[i])
                if P[i] > 23e9:  # perovskite
                    # print("mixture perovskite")
                    i_mixture_perovskite.append(i)
                else:
                    # print("mixture enstatite")
                    i_mixture_enstatite.append(i)

        ### Below I generate, pressure and temperatures for the entire mantle of the planet.

        # Documentation from pynbody copied below for reference, note that interpolation and evaluation are done in ONE step
        # unlike in Scipy
        # def interpolate2d(x, y, x_vals, y_vals, vals):
        #     """
        #     Interpolate on a 2D regular grid.
        #     Yields results identical to scipy.interpolate.interpn.
        #
        #     Input
        #     -----
        #
        #     x,y : points where the interpolation will be performed
        #
        #     x_vals, y_vals : xy values of the reference grid
        #
        #     vals : grid values
        #     """

        ### molten materials, getting T, P, rho, Cp
        # these arrays should be equivalent elementwise for whatever variable
        i_arrays = [i_liquid, i_mixture_enstatite, i_mixture_perovskite, i_solid_enstatite, i_solid_perovskite, i_solid_ppv]
        P_grid_mat = [P_grid, P_grid_ol, P_grid_pv, P_grid_ol, P_grid_pv, P_grid_ppv]
        T_grid_mat = [T_liq, T_mix_ol, T_mix_pv, T_sol_ol, T_sol_pv, T_ppv]
        rho_grid_mat = [rho_liq, rho_mix_ol, rho_mix_pv, rho_sol_ol, rho_sol_pv, rho_ppv]
        CP_grid_mat = [CP_liq, CP_mix_ol, CP_mix_pv, CP_sol_ol, CP_sol_pv, CP_ppv]
        # key: material_types = ["molten", "mix_mol_en", "mix_pv_en", "en", "pv", "ppv"]
        material_types = [0, 1, 2, 3, 4, 5]

        i = 0
        for i_arr, P_grid, T_grid, rho_grid, CP_grid, mat_type in zip(i_arrays, P_grid_mat, T_grid_mat, rho_grid_mat, CP_grid_mat, material_types):
            i += 1
            if len(i_arr) > 0:
                self.set_eos_values(mat_type, i_arr, P, y, P_grid, y_grid, T_grid, rho_grid, CP_grid)

    def test_plot(self):
        print(self.mantle_global_mat)
        print(max(self.mantle_global_T))
        plt.scatter(self.mantle_global_P/1e9, self.mantle_global_T, c=self.mantle_global_Cp)
        plt.vlines(23, 1000, 3000, color="k")
        plt.text(25, 2000, "perovskite")
        plt.text(23, 2000, "enstatite")

        plt.colorbar(label=r"$\rho \rm ~kg~m^{-3}$ ")
        plt.xlabel("P [GPa]")
        plt.ylabel("T [K]")
        plt.savefig("test_planet.png", dpi=300)

    ### get liquidus and solidus
    # P is in GPa
    def T_sol_fiq(self, P):
        value1 = 1621.0 + 38.415 * P - 0.1958 * P ** 2.0 + 3.8369e-4 * P ** 3.0
        value2 = 2045.0 * (P / 92.0 + 1.0) ** (1.0 / 1.3)
        if P < 40.0:
            if value1 < value2:
                value = value1
            else:
                value = value2
        else:
            value = value2
        return value


    def T_liq_fiq(self, P):
        value = 1940.0 * (P / 29.0 + 1.0) ** (1.0 / 1.9)
        return value

    ### get P, T, rho for a given material

    def set_eos_values(self, material_current, i_arr, P_chosen, y_chosen, P_grid, y_grid, T_grid, rho_grid, head_grid):
        temperatures = interpolate2d(P_chosen[i_arr], y_chosen[i_arr], P_grid, y_grid, T_grid)
        densities = interpolate2d(P_chosen[i_arr], y_chosen[i_arr], P_grid, y_grid, rho_grid)
        heat_capacities = interpolate2d(P_chosen[i_arr], y_chosen[i_arr], P_grid, y_grid, head_grid)
        self.mantle_global_T[i_arr] = temperatures
        self.mantle_global_P[i_arr] = P_chosen[i_arr]
        # print("chosen pressures ", self.mantle_global_P[i_arr])
        self.mantle_global_rho[i_arr] = densities
        self.mantle_global_Cp[i_arr] = heat_capacities
        self.mantle_global_mat[i_arr] = np.full(len(i_arr), material_current)


if __name__ == "__main__":  # only executes if running run.py versus calling a function
    entropies = [300, 3000, 4000]
    markers = [".", "D", "v"]
    min_density = 10000
    max_density = 0
    for S, marker in zip(entropies, markers):
        new_mantle = AdiabaticMantleEOS(need_plot=False, S_setting=S)
        if max_density < max(new_mantle.mantle_global_rho):
            max_density = max(new_mantle.mantle_global_rho)
        if min_density > min(new_mantle.mantle_global_rho):
            min_density = min(new_mantle.mantle_global_rho)
        plt.scatter(new_mantle.mantle_global_P/1e9, new_mantle.mantle_global_T, c=new_mantle.mantle_global_rho, label=f"S = {S}", marker=marker, vmin=2500, vmax=5500)
    print(min_density)
    print(max_density)
    plt.xlabel("P [GPa]")
    plt.ylabel("T [K]")

    plt.vlines(23, 0, 5000, color="k", ls="--")
    plt.text(25, 1000, "perovskite")
    plt.text(5, 1000, "enstatite")
    plt.legend()
    plt.colorbar(label=r"$\rho \rm ~[kg~m^{-3}]$ ")
    plt.savefig("overview_entropies.png", dpi=300)
